defsubr code (name, does) {
    ⌈ ( name does /flags/ --) Add new word to RAM dictionary. ⌉
    flags = 0
    x = len (State.RAM)
    State.RAM.append (State.LAST)
    State.RAM.append (name)
    State.RAM.append (flags)
    State.RAM.append (does)
    State.LAST = x

defsubr xdrop {
    ⌈ ( a -- ) ⌉
    %pop
}

defsubr xdup {
    ⌈ ( a -- a a ) ⌉
    deftemp A ⇐ %pop
    %push (A)
    %push (A)
}

defsubr xnegate {
    ⌈ ( n -- (-n) ) ⌉
    deftemp n ⇐ %pop
    %push (-n)
}

defsubr xemit {
    ⌈ ( c -- ) emit specified character ⌉
    deftemp c ⇐ %pop
    %printAsCharacter (c)
}

defsubr xdot { ⌈ ( n --) Print TOS ⌉ %print (%pop) %eol }
defsubr xdots { ⌈ ( --) Print stack contents ⌉ %print (%stack) %eol }

defsubr xadd {
    ⌈ ( a b -- sum) ⌉
    deftemp B ⇐ %pop
    deftemp A ⇐ %pop
    %push (A + B)
}

defsubr xmul {
    ⌈ ( a b -- product ) ⌉
    deftemp B ⇐ %pop
    deftemp A ⇐ %pop
    %push (A * B)
}

defsubr xeq {
    ⌈ ( a b -- bool ) ⌉
    deftemp B ⇐ %pop
    deftemp A ⇐ %pop
    %push (A == B)
}

defsubr xlt {
    ⌈ ( a b -- bool ) ⌉
    deftemp B ⇐ %pop
    deftemp A ⇐ %pop
    %push (A < B)
}

defsubr xgt {
    ⌈ ( a b -- bool ) ⌉
    deftemp B ⇐ %pop
    deftemp A ⇐ %pop
    %push (A > B)
}

defsubr xeq0 {
    ⌈ ( a -- bool ) ⌉
    deftemp a ⇐ %pop
    %push (a == 0)
}

defsubr x0lt {
    ⌈ ( a -- bool ) ⌉
    deftemp a ⇐ %pop
    %push (0 < a)
}

defsubr x0gt {
    ⌈ ( a -- bool ) ⌉
    deftemp a ⇐ %pop
    %push (0 > a)
}

defsubr xnot {
    ⌈ ( a -- bool ) ⌉
    deftemp a ⇐ %pop
    %push (not a)
}

defsubr xand {
    ⌈ ( a b -- bool ) ⌉
    deftemp b ⇐ %pop
    deftemp a ⇐ %pop
    %push (a and b)
}

defsubr xor {
    ⌈ ( a b -- bool ) ⌉
    deftemp b ⇐ %pop
    deftemp a ⇐ %pop
    %push (a or b)
}

defsubr xStoR {
    ⌈ ( a --  ) ⌉
    deftemp a ⇐ %pop
    %rpush (a)
}

defsubr xRtoS {
    ⌈ ( -- x ) ⌉
    deftemp x ⇐ %rpop
    %push (x)
}

defsubr xi {
    ⌈ ( -- i ) get current loop index from R stack ⌉
    deftemp i ⇐ %rtop
    %push (i)
}

defsubr xj {
    ⌈ ( -- j ) get outer loop index from R stack ⌉
    deftemp j ⇐ %rthird
    %push (j)
}

defsubr xswap {
    ⌈ ( a b -- b a) ⌉
    deftemp B ⇐ %pop
    deftemp A ⇐ %pop
    %push (B)
    %push (A)
}
defsubr xsub {
    ⌈ ( a b -- diff) ⌉
    deftemp B ⇐ %pop
    deftemp A ⇐ %pop
    %push (A - B)
}
defsubr xdiv {
    ⌈ ( a b -- div) ⌉
    xswap ()
    State.S.append (State.S.pop () / State.S.pop ())
}

defsubr xword {
    ⌈ (char -- string) Read in string delimited by char ⌉
    deftemp wanted ⇐ %popchar
    %scanfor (wanted)
}

⌈ Example of state-smart word, which Brodie sez not to do. Sorry, Leo... ⌉
⌈ This sin allows it to be used the same way compiling or interactive. ⌉
defsubr xquote {
    ⌈ ( -- string) Read up to closing dquote, push to stack ⌉
    ⌈ A string in Forth begins with the word " (followed by a space) then all characters up to the next " ⌉
    ⌈ E.G. " abc" ⌉
    defsynonym DQ ≡ 34
    %push (DQ)
    @xword
    [ %inCompilationState
        | yes: %funcall literalize ()
	| no: %pass
    ]
}

defsubr xdotquote {
    ⌈ ( -- ) parse and print a string ⌉
    ⌈ ." Hello, World!" ⌉
    @xquote
    deftemp s ⇐ %pop
    %print (s)
}

defsubr xcomment {
    ⌈ ( -- ) parse and discard a comment ⌉
    ⌈ e.g. ( a b c ) ⌉
    defsynonym RPAR ≡ 42
    %push(RPAR)
    @xword
    %pop
}

defsubr xdoliteral {
    ⌈ Inside definitions only, pushed comiled literal to stack ⌉


    

defsubr xbye { ⌈ ( --) Leave interpreter ⌉ %quit }

⌈ Example of state-smart word, which Brodie sez not to do. Sorry, Leo... ⌉
⌈ This sin allows it to be used the same way compiling or interactive. ⌉
defsubr xquote {
    "( -- string) Read up to closing quote, push to stack."
    %push (34);
    @xword
    if 1 == fvget("state") {
        @literalize
    }
}

defsubr xdotquote {
    ⌈ ( --) Print string. ⌉
    @xquote
    %print (%pop)
}

defsubr xcomment {
    ⌈ ( --) Read up to close paren. ⌉
}

=======================

def doliteral {
    ⌈ Inside definitions only, pushes compiled literal to stack. ⌉
    %push (RAM[IP])  # Push item at IP on stack.
    IP += 1          # Advance IP past item to continue execution.
def literalize():
    "Compile literal into definition."
    RAM.append(_find("(literal)"))  # Compile address of doliteral.
    RAM.append(S.pop())             # Compile literal value.



defsubr xinterpret {
    ⌈ ( string --) Execute word ⌉
    deftemp word ⇐ %pop
    if %empty-string? (word) {
        pass
    } else {
	deftemps found, subr ⇐ %lookup (subrs, word)
	if found {
	    @subr
	} elif %digits? (word) {
	    deftemp i ⇐ %toint (word)
	    %push (i)
	} else {
	    %print (word)
	    %print ("?")
	    %eol
	}
    }
}

defvar subrs ⇐ %freshdict
%assoc (subrs, "bye", ↪︎xbye)
%assoc (subrs, ".", ↪︎xdot)
%assoc (subrs, ".s", ↪︎xdots)
%assoc (subrs, "+", ↪︎xadd)
%assoc (subrs, "-", ↪︎xsub)
%assoc (subrs, "swap", ↪︎xswap)
%assoc (subrs, "word", ↪︎xword)
%assoc (subrs, "interpret", ↪︎xinterpret)

defsubr ok {
    ⌈ ( --) Interaction loop -- REPL ⌉
    defsynonym blank ≡ 32
    while ⊤ {
	%input
	while not %empty-input {
	    %push (blank)
	    @xword
	    @xinterpret
	}
    }
}

%exec ok
    
